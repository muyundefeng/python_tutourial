# python中基本的数据类型

## 数值类型

python支持四种基本的数值类型，分别是整数，长整数，浮点数以及复数，类型分别是int，long，float，complex

其中长整数没有上限与下限，复数是区别与其他与语言类型的。复数的表示方法存在**两种:a+bj或者complex\(a,b\)**

表示长整数的时候，需要在数字的末尾加上大写或者小写的l。

上面四种类型可以进行相互的转化，其中int\(x\)，long\(x\)，float\(x\)分别表示将x转化为整数，长整数以及浮点数三种类型。比较常见的几种表达式：repr\(x\)将字符串x转化为表达式；**eval\(x\)执行x中有效的python表达式，并返回结果；**chr\(x\)将x转化为字符；ord\(x\)将一个字符转化为它的整数。

## python中的数学函数

| 函数名称 | 含义 |
| :--- | :--- |
| abs\(x\) | x的绝对值 |
| ceil\(x\) | 返回数字上整数,ceil\(4.1\)=5 |
| floor\(x\) | 返回数字的下舍证书，ceil\(4.9\)=4 |
| max\(x1,x2,.....\) | 返回列表中的最大值 |
| min\(x1,x2,....\) | 返回列表中的最小值 |
| round\(x,\[n\]\) | 返回x的四舍五入值，并保留n位小数 |

## python中的随机函数

| 函数名称 | 含义 |
| :--- | :--- |
| choice\(seq\) | 返回seq随机一个数值，例如choice\(rang\(1,10\)\)可能返回9 |

## python中的字符串操作

| 函数 | 含义 |
| :--- | :--- |
| a\[1:5\] | 返回字符串a的第二个字符到第五个字符，不包括第五个 |
| a\[\] | 通过索引获取所在位置的字符 |
| a** in** A | A中是否包含a字符串 |
| a not in A | A中不包含a返回True，否则False |
| r/R | 所有的字符串按照字面意思来用，例如r'\n'返回\n |

### 字符串的格式化

主要的操作符为**%**

其中%s与%d分别表示格式化字符串与整数。例子如下:

print 'my name is** %s,d%** years old' _**%**_ \('tom',21\)

输出为my name is tom,21 years old

### 三引号

python中的三引号，通常引用html或者sql，可以避免很多转移字符的出现。

## python中的列表

python中的里列表类似于java中的list。

| 方法 | 含义 |
| :--- | :--- |
| min\(list\) | 返回list中的最小值 |
| max\(list\) | 返回list中的最大值 |
| list.append\(q\) | list中追加元素 |
| list.extend\(list1\) | list中扩充序列,list1放在list尾部 |
| list.index\(obj\) | 返回匹配到第一个obj的索引 |
| list.pop\(\) | 移除最后一个元素，并返回该元素的值 |
| list.reverse\(\) | 反转列表 |
| list.sort\(func\) | 对list进行排序 |

字典常用的操作方法

| 方法名称 | 含义 |
| :--- | :--- |
| dict.clear\(\) | 清除字典的内容 |
| **dict.fromkeys\(seq\[, val\]\)** | **创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值** |
| dict.has\_key\(key\) | 判断字典中是否包含key的键 |
| **dict.items\(\)** | **返回（k,v）组成的元组** |
| dict.keys\(\) | 以列表返回一个字典所有键 |
| dict.pop\(key\) | 删除指定的key |

## python中的IO操作

读取键盘输入

raw\_input\(\)函数从标准输入读取一行，并返回一个字符串

**input\(\)函数接受一个python函数表达式，并将结果返回**

_请输入：\[x\*5 for x in range\(2,10,2\)\]  
_

_你输入的内容是:  \[10, 20, 30, 40\]_

### 文件操作模式open\(file\_name,mode\)

| 模式 | 含义 |
| :--- | :--- |
| r | **只读**文件，文件指针放在文件开头 |
| r+ | 打开文件用于**读写**，指针放在头部 |
| w+ | 打开一个文件**用于读写**。如果**该文件已存在则将其覆盖。如果该文件不存在，创建新文件。** |
| w | 打开一个文件**只用于写入**。**如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件** |
| a | 打开一个文件用于**追加**。如果该文件已存在，**文件指针将会放在文件的结尾**。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 |

**write\(\)方法不会在字符串的结尾添加换行符\('\n'\)：**

## python中的目录操作

| 方法 | 描述 |
| :--- | :--- |
| os.mkdir\('test'\) | 创建test目录 |
| os.rmdir\('dirname'\) | 删除dirname目录 |

```
try:
<语句>        #运行别的代码
except <名字>：
<语句>        #如果在try部份引发了'name'异常
except <名字>，<数据>:
<语句>        #如果引发了'name'异常，获得附加的数据
else:
<语句>        #如果没有异常发生
```

try的工作原理是，当开始一个try语句后，python就在当前程序的上下文中作标记，这样当异常出现时就可以回到这里，try子句先执行，接下来会发生什么依赖于执行时是否出现异常。（**与java异常处理完全一样**，多了一个关键字else）

1. **如果当try后的语句执行时发生异常，python就跳回到try并执行第一个匹配该异常的except子句，异常处理完毕，控制流就通过整个try语句（除非在处理异常时又引发新的异常）。   **
2. **如果在try后的语句里发生了异常，却没有匹配的except子句，异常将被递交到上层的try，或者到程序的最上层（这样将结束程序，并打印缺省的出错信息）。   **
3. **如果在try子句执行时没有发生异常，python将执行else语句后的语句（如果有else的话），然后控制流通过整个try语句。**

try-finally 语句无论是否发生异常都将执行最后的代码。

